function y = fast_conv_os(x_long, h, nfft)
% =========================================================================
%              重叠保留法 (Overlap-Save) 快速卷积算法实现
% =========================================================================
%
% 【算法概述】
%   本函数使用重叠保留法 (Overlap-Save, 也称 Overlap-Discard) 实现长序列
%   与短滤波器的快速线性卷积。该算法是数字信号处理中处理长数据流卷积的
%   经典方法之一。
%
%   核心思想: 利用 FFT 的圆周卷积特性，通过分块处理实现线性卷积
%   - 将长输入信号分割成重叠的固定长度块
%   - 每块使用 FFT 进行快速圆周卷积
%   - 丢弃每块中受圆周混叠影响的样本，保留有效部分
%   - 将各块的有效部分拼接得到完整的线性卷积结果
%
% 【应用场景】
%   1. 实时音频/视频信号处理 (FIR 滤波)
%   2. 通信系统中的匹配滤波
%   3. 大规模数据的卷积运算
%   4. 流式数据处理 (适合边接收边处理)
%
% 【直接卷积 vs 快速卷积】
%
%   直接卷积 (时域):
%       y[n] = Σ(k=0 to M-1) h[k] · x[n-k]
%       复杂度: O(N × M)，其中 N 为信号长度，M 为滤波器长度
%
%   快速卷积 (频域):
%       Y = IFFT(FFT(x) · FFT(h))
%       复杂度: O(N · log₂N)
%
%   当 M 较大时 (通常 M > 64)，快速卷积更高效
%
% 【为什么需要分块处理？】
%
%   问题: 当输入信号 x 很长 (如实时音频流) 时:
%     1. 无法预知信号总长度
%     2. 一次性 FFT 需要巨大内存
%     3. 延迟过大，不适合实时应用
%
%   解决: 将长信号分成固定长度的块，逐块处理
%
% 【圆周卷积与线性卷积的关系】
%
%   N 点圆周卷积: y_c[n] = IFFT(FFT(x, N) · FFT(h, N))
%
%   关键定理: 若 N ≥ Lx + M - 1，则圆周卷积 = 线性卷积
%
%   当 N < 所需长度时，会发生时域混叠 (aliasing)
%   混叠只影响前 M-1 个样本，后面的样本仍是正确的线性卷积结果
%
% 【重叠保留法原理】
%
%   符号定义:
%     M     = 滤波器 h 的长度
%     nfft  = FFT 点数 (必须是 2 的幂)
%     L     = nfft - M + 1 = 每块输出的有效样本数
%
%   核心观察:
%     对于长度 nfft 的数据块与长度 M 的滤波器进行 N 点圆周卷积:
%     - 前 M-1 个输出样本受时域混叠影响 → 丢弃
%     - 后 L = nfft-M+1 个样本是正确的线性卷积 → 保留
%
% 【算法步骤】
%
%   步骤 0: 预处理
%     - 在输入信号 x 前端补 M-1 个零
%     - 计算滤波器的 nfft 点 FFT: H = FFT(h, nfft)
%
%   步骤 1: 分块提取 (有重叠)
%     - 第 i 块: x_padded[(i-1)·L + 1 : (i-1)·L + nfft]
%     - 相邻块重叠 M-1 个样本
%
%   步骤 2: 块卷积
%     - X_block = FFT(当前块)
%     - Y_block = X_block · H  (频域乘法 = 圆周卷积)
%     - y_block = IFFT(Y_block)
%
%   步骤 3: 保留有效部分
%     - 丢弃 y_block 的前 M-1 个样本
%     - 保留后 L 个样本 → 追加到输出
%
%   步骤 4: 裁剪输出
%     - 最终输出长度 = Lx + M - 1 (标准线性卷积长度)
%
% 【算法示意图 (nfft=8, M=3, L=6)】
%
%   输入信号 x (补零后):
%   ┌───────────────────────────────────────────────┐
%   │ 0  0 │ x₁ x₂ x₃ x₄ x₅ x₆ │ x₇ x₈ x₉ ... │
%   └───────────────────────────────────────────────┘
%        ↑
%      M-1 个零
%
%   块 1: [0, 0, x₁, x₂, x₃, x₄, x₅, x₆]  长度 = nfft = 8
%              ├──────────────────────┤
%              丢弃前 2 个    保留后 6 个
%
%   块 2: [x₅, x₆, x₇, x₈, x₉, x₁₀, x₁₁, x₁₂]
%              ├──────────────────────┤
%              丢弃        保留                    ← 与块 1 重叠 2 个样本
%
%   输出拼接:
%   ┌────────────────────────────────────────┐
%   │ y₁ y₂ y₃ y₄ y₅ y₆ │ y₇ y₈ y₉ ... │
%   └────────────────────────────────────────┘
%         块 1 有效输出       块 2 有效输出
%
% 【与重叠相加法 (Overlap-Add) 的比较】
%
%   ┌─────────────┬──────────────────┬──────────────────┐
%   │   特性       │   Overlap-Save    │   Overlap-Add    │
%   ├─────────────┼──────────────────┼──────────────────┤
%   │ 输入块      │  重叠 (M-1 样本)   │  不重叠          │
%   │ 每块输入长度 │  nfft            │  L (= nfft-M+1)  │
%   │ 每块输出长度 │  L (丢弃 M-1)     │  nfft (需叠加)    │
%   │ 输出处理    │  直接拼接         │  重叠部分相加     │
%   │ 内存效率    │  稍高             │  需额外缓冲       │
%   │ 适用场景    │  实时流处理       │  离线批处理       │
%   └─────────────┴──────────────────┴──────────────────┘
%
% 【计算复杂度分析】
%
%   设: N = 输入信号长度, M = 滤波器长度, nfft = FFT 点数
%
%   块数: K = ceil(N / L) ≈ N / L
%
%   每块计算量:
%     - FFT: O(nfft · log₂(nfft))
%     - 频域乘法: O(nfft)
%     - IFFT: O(nfft · log₂(nfft))
%
%   总复杂度: O(K · nfft · log₂(nfft)) = O(N · nfft · log₂(nfft) / L)
%            ≈ O(N · log₂(nfft))  (当 nfft >> M 时)
%
%   vs 直接卷积: O(N · M)
%
%   当 M > log₂(nfft) 时，快速卷积更高效
%
% 【nfft 选择建议】
%
%   1. nfft 必须是 2 的幂: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ...
%   2. nfft ≥ M (滤波器长度)
%   3. 有效块长度 L = nfft - M + 1 应足够大以提高效率
%   4. 推荐: nfft ≈ 4M ~ 8M (经验值，平衡效率和内存)
%
%   示例:
%     M = 64 (滤波器长度)
%     推荐 nfft = 256 或 512
%     L = 256 - 64 + 1 = 193 或 L = 512 - 64 + 1 = 449
%
% 【输入参数】
%   x_long - 长输入信号序列，复数或实数列向量
%            - 长度可以是任意正整数 (不要求是 2 的幂)
%            - 如果输入为行向量，将自动转换为列向量
%
%   h      - FIR 滤波器系数 (脉冲响应)，复数或实数列向量
%            - 长度 M 可以是任意正整数
%            - 通常 M << length(x_long)
%
%   nfft   - FFT 点数，必须满足:
%            - 是 2 的整数次幂 (如 64, 128, 256, ...)
%            - nfft ≥ M
%
% 【输出参数】
%   y      - x_long 与 h 的线性卷积结果，列向量
%            - 长度 = length(x_long) + length(h) - 1
%            - 与 conv(x_long, h) 的结果相同 (在数值精度范围内)
%
% 【使用示例】
%
%   % 示例 1: 基本用法 - FIR 低通滤波
%   Fs = 1000;                            % 采样频率 1000 Hz
%   t = 0:1/Fs:1-1/Fs;                    % 1 秒信号
%   x = sin(2*pi*50*t) + sin(2*pi*200*t); % 50Hz + 200Hz 混合信号
%   x = x(:);                             % 转为列向量
%
%   % 设计低通滤波器 (截止频率 100Hz)
%   h = fir1(63, 100/(Fs/2));             % 64 阶 FIR 滤波器
%   h = h(:);
%
%   % 使用快速卷积进行滤波
%   nfft = 256;                           % FFT 点数
%   y = fast_conv_os(x, h, nfft);
%
%   % 验证结果
%   y_ref = conv(x, h);                   % MATLAB 内置卷积
%   max_error = max(abs(y - y_ref));
%   fprintf('与 conv() 的最大误差: %.2e\n', max_error);
%
%   % 示例 2: 选择合适的 nfft
%   M = length(h);                        % 滤波器长度
%   nfft_options = [128, 256, 512, 1024];
%   for nfft = nfft_options
%       L = nfft - M + 1;                 % 有效块长度
%       efficiency = L / nfft * 100;       % 效率百分比
%       fprintf('nfft=%d, L=%d, 效率=%.1f%%\n', nfft, L, efficiency);
%   end
%
% 【注意事项】
%   1. 输出长度为 Lx + M - 1，这是标准线性卷积的长度
%   2. 对于实时处理，可以修改本函数为流式版本，逐块输出
%   3. 若 nfft 过小 (接近 M)，效率会降低；若过大，内存开销增加
%   4. 本实现使用 my_fft 和 my_ifft，确保这两个函数可用
%
% 【延迟分析 (实时应用)】
%   算法延迟 = nfft 个采样点 = nfft / Fs 秒
%   例如: nfft = 256, Fs = 8000 Hz → 延迟 = 32 ms
%
% 【参考文献】
%   [1] Oppenheim, A.V., Schafer, R.W. "Discrete-Time Signal Processing"
%   [2] Proakis, J.G., Manolakis, D.G. "Digital Signal Processing"
%   [3] 程佩青. 数字信号处理教程 (第五版). 清华大学出版社
%
% =========================================================================

% =====================================================================
% 步骤 0: 输入预处理与参数初始化
% =====================================================================

% 确保输入为列向量
% MATLAB 卷积运算以列向量为标准格式
if size(x_long, 2) > 1
    x_long = x_long(:);  % 将行向量转换为列向量
end
if size(h, 2) > 1
    h = h(:);  % 将行向量转换为列向量
end

M = length(h);      % 滤波器长度
Lx = length(x_long); % 输入信号长度

% =====================================================================
% 步骤 1: 参数验证
% =====================================================================

% 验证 nfft 是 2 的整数次幂
% FFT 算法要求长度为 2^m (m 为正整数)
if mod(log2(nfft), 1) ~= 0
    error('nfft必须是2的整数次幂 (如 64, 128, 256, 512, ...)');
end

% 验证 nfft 足够大
% nfft 必须至少等于滤波器长度，否则无法避免全部混叠
if nfft < M
    error('nfft必须大于等于滤波器长度M (当前 nfft=%d, M=%d)', nfft, M);
end

% =====================================================================
% 步骤 2: 计算关键参数
% =====================================================================

% 有效数据块长度: 每个 nfft 点的块中，只有 L 个样本是有效的线性卷积结果
% L = nfft - M + 1
% 直观理解: nfft 点圆周卷积的前 M-1 个点受混叠影响，需丢弃
L = nfft - M + 1;

% =====================================================================
% 步骤 3: 预计算滤波器的频域表示
% =====================================================================
% 将滤波器补零到 nfft 长度后进行 FFT
% 这个结果在所有块中重复使用，只需计算一次
%
% h:        [h₁, h₂, ..., h_M]
% h_padded: [h₁, h₂, ..., h_M, 0, 0, ..., 0]  (长度 = nfft)
h_padded = [h; zeros(nfft - M, 1)];
H = my_fft(h_padded);  % 滤波器的频率响应

% =====================================================================
% 步骤 4: 输入信号前端补零
% =====================================================================
% 在输入信号前端补 M-1 个零
% 目的: 确保第一个输出块的有效部分从 y[1] 开始
%
% 数学原因:
%   线性卷积 y[n] = Σ(k=0 to M-1) h[k]·x[n-k]
%   当 n < M-1 时，需要 x 的负索引值
%   补零相当于假设 x[-1] = x[-2] = ... = x[-(M-1)] = 0
%
% 图示:
%   原始 x:    [x₁, x₂, x₃, ..., x_Lx]
%   补零后:    [0, 0, ..., 0, x₁, x₂, x₃, ..., x_Lx]
%              └──── M-1 ────┘
x_padded = [zeros(M-1, 1); x_long];
Lx_padded = length(x_padded);  % 补零后的长度 = Lx + M - 1

% =====================================================================
% 步骤 5: 计算需要处理的块数
% =====================================================================
% 每块有效输出 L 个样本，总共需要 ceil(Lx_padded / L) 个块
% 向上取整确保覆盖所有输入数据
num_blocks = ceil(Lx_padded / L);

% =====================================================================
% 步骤 6: 初始化输出数组
% =====================================================================
% 使用动态数组拼接，适用于块数不确定的情况
% 对于已知块数的情况，也可预分配: y = zeros(num_blocks * L, 1);
y = [];

% =====================================================================
% 步骤 7: 逐块处理 (主循环)
% =====================================================================
for i = 1:num_blocks
    % -----------------------------------------------------------------
    % 7.1: 计算当前块的索引范围
    % -----------------------------------------------------------------
    % 块起始位置: 第 i 块从第 (i-1)*L + 1 个样本开始
    % 相邻块之间重叠 M-1 个样本
    %
    % 图示 (nfft=8, M=3, L=6):
    %   块 1: 位置 1 ~ 8
    %   块 2: 位置 7 ~ 14  (与块 1 重叠位置 7~8，共 M-1=2 个)
    %   块 3: 位置 13 ~ 20 (与块 2 重叠位置 13~14)
    block_start = (i-1) * L + 1;
    block_end = min(block_start + nfft - 1, Lx_padded);
    
    % -----------------------------------------------------------------
    % 7.2: 提取当前块并补零
    % -----------------------------------------------------------------
    % 如果当前块不足 nfft 长度 (最后一块可能发生)，用零填充
    current_block = x_padded(block_start:block_end);
    if length(current_block) < nfft
        current_block = [current_block; zeros(nfft - length(current_block), 1)];
    end
    
    % -----------------------------------------------------------------
    % 7.3: FFT - 将当前块变换到频域
    % -----------------------------------------------------------------
    X_block = my_fft(current_block);
    
    % -----------------------------------------------------------------
    % 7.4: 频域乘法 (等价于时域圆周卷积)
    % -----------------------------------------------------------------
    % 卷积定理: 时域卷积 ↔ 频域乘法
    % Y[k] = X[k] · H[k], k = 0, 1, ..., nfft-1
    Y_block = X_block .* H;
    
    % -----------------------------------------------------------------
    % 7.5: IFFT - 将结果变换回时域
    % -----------------------------------------------------------------
    % y_block 是当前块的圆周卷积结果，长度 = nfft
    y_block = my_ifft(Y_block);
    
    % -----------------------------------------------------------------
    % 7.6: 保留有效部分 (Overlap-Save 核心步骤)
    % -----------------------------------------------------------------
    % 圆周卷积的前 M-1 个样本受时域混叠影响，必须丢弃
    % 只保留从第 M 个样本开始的 L 个有效样本
    %
    % y_block: [混叠₁, 混叠₂, ..., 混叠_{M-1}, 有效₁, 有效₂, ..., 有效_L]
    %          └────────── 丢弃 ──────────┘  └────────── 保留 ──────────┘
    valid_samples = y_block(M:end);  % 提取有效样本 (从第 M 个到结尾)
    
    % -----------------------------------------------------------------
    % 7.7: 拼接到输出
    % -----------------------------------------------------------------
    % 将当前块的有效样本追加到输出数组
    y = [y; valid_samples];
end

% =====================================================================
% 步骤 8: 裁剪输出到标准线性卷积长度
% =====================================================================
% 线性卷积的标准输出长度 = Lx + M - 1
% 由于分块处理可能产生额外样本，需要裁剪
final_length = Lx + M - 1;
y = y(1:final_length);

% 返回结果
% y 为 x_long 与 h 的线性卷积，与 conv(x_long, h) 结果一致
end
