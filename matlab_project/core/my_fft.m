function X = my_fft(x)
% =========================================================================
%                       基2-FFT (按时间抽取 DIT) 算法实现
% =========================================================================
%
% 【算法概述】
%   本函数实现了 Cooley-Tukey 基2快速傅里叶变换 (FFT) 算法，采用按时间抽取
%   (Decimation In Time, DIT) 的迭代蝶形运算结构。
%
%   FFT 是离散傅里叶变换 (DFT) 的高效计算方法:
%   - 直接计算 DFT 的复杂度为 O(N²)
%   - FFT 将复杂度降低至 O(N·log₂N)
%
% 【DFT 定义】
%   对于长度为 N 的序列 x[n]，其 DFT 定义为:
%
%       X[k] = Σ(n=0 to N-1) x[n] · W_N^(nk)
%
%   其中 W_N = e^(-j·2π/N) 称为旋转因子 (Twiddle Factor)
%
% 【DIT-FFT 核心思想】
%   将 N 点 DFT 按照输入序列索引的奇偶性分解:
%   
%   1. 偶数索引项: x[0], x[2], x[4], ... → 构成 N/2 点 DFT
%   2. 奇数索引项: x[1], x[3], x[5], ... → 构成 N/2 点 DFT
%
%   利用 DFT 的周期性和对称性，通过蝶形运算合并结果:
%
%       X[k] = X_even[k] + W_N^k · X_odd[k]
%       X[k + N/2] = X_even[k] - W_N^k · X_odd[k]
%
% 【蝶形运算】
%                    ┌─────────────┐
%       a ────●─────┤  a + W·b    ├──── A (输出上半部分)
%             │×W   └─────────────┘
%             ╳
%             │     ┌─────────────┐
%       b ────●─────┤  a - W·b    ├──── B (输出下半部分)
%                   └─────────────┘
%
%   其中 W 为对应的旋转因子
%
% 【比特反转 (Bit-Reversal)】
%   DIT-FFT 要求输入序列按照比特反转顺序重新排列。
%   例如 N=8 时:
%       原索引:  0(000) 1(001) 2(010) 3(011) 4(100) 5(101) 6(110) 7(111)
%       反转后:  0(000) 4(100) 2(010) 6(110) 1(001) 5(101) 3(011) 7(111)
%
% 【算法流程图 (N=8 为例)】
%
%   输入索引:    0    4    2    6    1    5    3    7   (比特反转后)
%                │    │    │    │    │    │    │    │
%   Stage 1:     └──●─┘    └──●─┘    └──●─┘    └──●─┘   (span=2, W_2^0)
%                   │         │         │         │
%   Stage 2:     ┌──┴──●──────┘    ┌──┴──●──────┘       (span=4, W_4^0, W_4^1)
%                │                 │
%   Stage 3:     └────────●────────┘                    (span=8, W_8^0..W_8^3)
%                         │
%   输出索引:    0    1    2    3    4    5    6    7
%
% 【本实现的优化要点】
%   1. 迭代实现: 消除递归开销，更适合硬件映射 (FPGA/ASIC)
%   2. 缓存机制: 预计算并缓存比特反转索引和旋转因子，避免重复计算
%   3. 向量化运算: 利用 MATLAB 矩阵运算特性，减少循环开销
%   4. 内存高效: 原址 (in-place) 计算，仅需 O(N) 额外空间
%
% 【输入参数】
%   x - 输入信号，复数列向量
%       - 长度 N 必须是 2 的整数次幂 (如 2, 4, 8, 16, 32, ...)
%       - 如果输入为行向量，将自动转换为列向量
%
% 【输出参数】
%   X - x 的 N 点 DFT 结果，复数列向量
%       - X(k) 对应频率分量 f_k = (k-1) × Fs / N，其中 Fs 为采样频率
%
% 【使用示例】
%   % 生成测试信号: 50Hz + 120Hz 正弦波
%   Fs = 1000;                        % 采样频率 1000 Hz
%   t = 0:1/Fs:0.2-1/Fs;              % 采样时间向量
%   x = sin(2*pi*50*t) + sin(2*pi*120*t);  % 双频正弦波
%   
%   % 计算 FFT
%   N = 256;                          % FFT 点数
%   X = my_fft(x(1:N).');             % 取前 N 点计算 FFT
%   
%   % 绘制频谱
%   f = Fs*(0:N-1)/N;                 % 频率轴
%   plot(f(1:N/2), abs(X(1:N/2)));    % 绘制单边幅度谱
%
% 【参考文献】
%   [1] Cooley, J.W., Tukey, J.W. (1965). "An algorithm for the machine 
%       calculation of complex Fourier series"
%   [2] Oppenheim, A.V., Schafer, R.W. "Discrete-Time Signal Processing"
%
% =========================================================================

    % =====================================================================
    % 步骤 0: 输入预处理
    % =====================================================================
    
    % 确保输入为列向量
    % MATLAB 中向量运算通常以列向量为主，统一格式便于后续处理
    if size(x, 2) > 1
        x = x(:);  % 将行向量或矩阵转换为列向量
    end

    N = length(x);  % 获取输入信号长度

    % 验证 N 是 2 的整数次幂
    % FFT 基2算法要求输入长度为 2^m (m 为正整数)
    % log2(N) 若为整数，则 mod(log2(N), 1) == 0
    if N == 0 || mod(log2(N), 1) ~= 0
        error('输入长度必须是2的整数次幂 (如 2, 4, 8, 16, 32, ...)');
    end

    % =====================================================================
    % 步骤 1: 获取预计算缓存
    % =====================================================================
    % 缓存机制可显著提升多次相同长度 FFT 的计算效率
    % 缓存内容包括:
    %   - 比特反转索引表
    %   - 每个 stage 的旋转因子表
    cache = get_fft_cache(N);

    % =====================================================================
    % 步骤 2: 比特反转重排 (Bit-Reversal Permutation)
    % =====================================================================
    % 将输入序列按照比特反转后的索引重新排列
    % 这是 DIT-FFT 算法的前提条件，确保蝶形运算的正确性
    %
    % 例如 N=8:
    %   原始顺序: x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7]
    %   重排后:   x[0], x[4], x[2], x[6], x[1], x[5], x[3], x[7]
    X = x(cache.bitrev_idx);

    % =====================================================================
    % 步骤 3: 迭代蝶形运算 (Butterfly Operations)
    % =====================================================================
    % 共进行 log2(N) 个 stage
    % 每个 stage 包含 N/2 个蝶形运算
    
    for stage = 1:cache.num_stages
        % -----------------------------------------------------------------
        % 获取当前 stage 的参数
        % -----------------------------------------------------------------
        span = cache.stage_span(stage);      % 当前 stage 的蝶形跨度 (2^stage)
        half_span = span / 2;                % 半跨度 = 蝶形运算的组内元素数
        W = cache.stage_twiddles{stage};     % 当前 stage 的旋转因子向量
        
        % -----------------------------------------------------------------
        % 利用 reshape 实现高效的分组蝶形运算
        % -----------------------------------------------------------------
        % 将长度 N 的向量重塑为 span × (N/span) 的矩阵
        % 每列代表一个独立的蝶形运算组
        %
        % 例如 N=8:
        %   stage=1 (span=2):
        %       X = [a, b, c, d, e, f, g, h]'
        %       重塑后:
        %           [ a  c  e  g ]
        %           [ b  d  f  h ]
        %       每列对应一个 2 点蝶形组 (a,b), (c,d), (e,f), (g,h)
        %
        %   stage=2 (span=4):
        %       X = [a, b, c, d, e, f, g, h]'
        %       重塑后:
        %           [ a  e ]
        %           [ b  f ]
        %           [ c  g ]
        %           [ d  h ]
        %       第1列和第2列分别形成两个独立的 4 点蝶形组
        %
        %   stage=3 (span=8):
        %       X = [a, b, c, d, e, f, g, h]'
        %       重塑后:
        %           [ a ]
        %           [ b ]
        %           [ c ]
        %           [ d ]
        %           [ e ]
        %           [ f ]
        %           [ g ]
        %           [ h ]
        %       整列构成单个 8 点蝶形组
        X = reshape(X, span, []);
        % reshape 很巧，得结合 reshape 前后的数据排列理解其效果
        
        % -----------------------------------------------------------------
        % 蝶形运算核心计算
        % -----------------------------------------------------------------
        % 上半部分 (top): 蝶形运算的 "a" 输入
        % 下半部分 (bot): 蝶形运算的 "b" 输入
        top_val = X(1:half_span, :);         % 提取上半部分
        bot_val = X(half_span + 1:end, :);   % 提取下半部分
        
        % 旋转因子乘法: W * bot_val
        % W 为列向量，通过广播机制与 bot_val 的每一列相乘
        twiddle_mul = W .* bot_val;
        
        % 蝶形运算公式:
        %   A = a + W·b  (加法支路，存入上半部分)
        %   B = a - W·b  (减法支路，存入下半部分)
        %
        % 可视化 (延续上面的重塑示例，N=8):
        %   stage=1 (span=2, W=[1]):
        %       top_val = [a c e g], bot_val = [b d f h]
        %       输出上半: [a+b, c+d, e+f, g+h]
        %       输出下半: [a-b, c-d, e-f, g-h]
        %
        %   stage=2 (span=4, W=[1; W_8^2]):
        %       top_val = [a e; b f], bot_val = [c g; d h]
        %       W = [1; W_8^2] = [1; -j]
        %       输出上半: [a + 1*c, e + 1*g; b + (-j)*d, f + (-j)*h]
        %       输出下半: [a - 1*c, e - 1*g; b - (-j)*d, f - (-j)*h]
        %
        %   stage=3 (span=8, W=[1; W_8^1; W_8^2; W_8^3]):
        %       top_val = [a; b; c; d], bot_val = [e; f; g; h]
        %       W = [1; W_8^1; W_8^2; W_8^3]
        %       输出上半: top_val + W.*bot_val (列向量相乘后相加)
        %       输出下半: top_val - W.*bot_val
        X(1:half_span, :) = top_val + twiddle_mul;      % 蝶形输出上半
        X(half_span + 1:end, :) = top_val - twiddle_mul; % 蝶形输出下半
        
        % -----------------------------------------------------------------
        % 恢复为列向量，准备下一个 stage
        % -----------------------------------------------------------------
        % 例如 N=8 (沿用上面的 a..h 符号):
        %   stage=1 输出矩阵 (2×4):
        %       [ a+b   c+d   e+f   g+h
        %         a-b   c-d   e-f   g-h ]
        %     经 X(:) 展开为列向量:
        %       [a+b; a-b; c+d; c-d; e+f; e-f; g+h; g-h]
        %
        %   stage=2 输出矩阵 (4×2) 记为列主序 [col1 col2]:
        %       X(:) 展开顺序是 [col1; col2]，即先取第1列的4个元素，再取第2列的4个元素
        %     这保持了后续 stage 的输入按列连续存放的约定
        %
        %   stage=3 输出矩阵 (8×1):
        %     已是列向量，X(:) 不改变排列
        X = X(:);
    end
    
    % 返回计算结果
    % X 为输入信号 x 的 N 点 DFT
end


% =========================================================================
% 辅助函数: 获取 FFT 缓存
% =========================================================================
function cache = get_fft_cache(N)
% get_fft_cache: 获取或生成给定长度 N 的 FFT 计算缓存
%
% 【功能描述】
%   使用 persistent 变量实现缓存机制，存储已计算过的:
%   - 比特反转索引表
%   - 每个 stage 的旋转因子表
%
%   当多次调用相同长度的 FFT 时，避免重复计算这些固定参数
%
% 【输入参数】
%   N - FFT 点数 (必须是 2 的整数次幂)
%
% 【输出参数】
%   cache - 结构体，包含以下字段:
%       .N             - FFT 点数
%       .num_stages    - stage 数量 (log2(N))
%       .bitrev_idx    - 比特反转索引数组 (N×1)
%       .stage_span    - 每个 stage 的跨度数组 (num_stages×1)
%       .stage_twiddles - 每个 stage 的旋转因子 (cell 数组)

    % persistent 变量在函数调用之间保持值
    % 用于实现简单的缓存机制
    persistent cached_N cached_data

    % 首次调用时初始化缓存容器
    if isempty(cached_N)
        cached_N = [];      % 存储已缓存的 N 值
        cached_data = {};   % 存储对应的缓存数据
    end

    % 检查是否已有该 N 的缓存
    idx = find(cached_N == N, 1);
    
    if isempty(idx)
        % -----------------------------------------------------------------
        % 缓存未命中: 需要计算新的缓存数据
        % -----------------------------------------------------------------
        
        % 计算 stage 数量 = log2(N)
        % 例如 N=8 → 3 个 stage
        num_stages = log2(N);

        % 生成比特反转索引表
        bitrev_idx = compute_bitrev_indices(N);
        
        % -----------------------------------------------------------------
        % 预计算所有旋转因子 (Twiddle Factors)
        % -----------------------------------------------------------------
        % 基本旋转因子: W_N^k = e^(-j·2π·k/N), k = 0, 1, ..., N/2-1
        %
        % 数学原理:
        %   W_N^k = cos(2πk/N) - j·sin(2πk/N)
        %
        % 只需计算 N/2 个旋转因子，因为:
        %   W_N^(k+N/2) = -W_N^k (半周期对称性)
        twiddle_full = exp(-1j * 2 * pi * (0:(N/2 - 1)) / N).';

        % 初始化每个 stage 的参数存储
        stage_span = zeros(num_stages, 1);
        stage_twiddles = cell(num_stages, 1);

        % 为每个 stage 提取所需的旋转因子
        for stage = 1:num_stages
            % span: 当前 stage 蝶形组的大小 = 2^stage
            % 例如: stage 1 → span=2, stage 2 → span=4, ...
            span = 2^stage;
            half_span = span / 2;
            
            % stride: 旋转因子的取样间隔
            % stride = N / span = 2^(log2(N) - stage)
            %
            % 例如 N=8:
            %   stage 1: stride=4, 使用 W_8^0 (= W_2^0)
            %   stage 2: stride=2, 使用 W_8^0, W_8^2 (= W_4^0, W_4^1)
            %   stage 3: stride=1, 使用 W_8^0, W_8^1, W_8^2, W_8^3
            stride = N / span;
            
            % 计算当前 stage 需要的旋转因子索引
            % idx_vec = [0, stride, 2*stride, ...] + 1 (MATLAB 索引从 1 开始)
            idx_vec = (0:half_span-1) * stride + 1;
            
            % 存储当前 stage 的参数
            stage_span(stage) = span;
            stage_twiddles{stage} = twiddle_full(idx_vec);
        end

        % 构建缓存结构体
        cache = struct( ...
            'N', N, ...
            'num_stages', num_stages, ...
            'bitrev_idx', bitrev_idx, ...
            'stage_span', stage_span, ...
            'stage_twiddles', {stage_twiddles} ...  % 注意 cell 需要 {} 包裹
        );

        % 将新缓存加入存储
        cached_N(end + 1) = N;
        cached_data{end + 1} = cache;
    else
        % -----------------------------------------------------------------
        % 缓存命中: 直接返回已有数据
        % -----------------------------------------------------------------
        cache = cached_data{idx};
    end
end


% =========================================================================
% 辅助函数: 计算比特反转索引
% =========================================================================
function idx = compute_bitrev_indices(N)
% compute_bitrev_indices: 生成长度为 N 的比特反转索引数组
%
% 【算法原理】
%   对于 0 到 N-1 的每个索引，将其二进制表示反转后得到新索引
%
%   例如 N=8 (3位二进制):
%       0 = 000 → 反转 → 000 = 0
%       1 = 001 → 反转 → 100 = 4
%       2 = 010 → 反转 → 010 = 2
%       3 = 011 → 反转 → 110 = 6
%       4 = 100 → 反转 → 001 = 1
%       5 = 101 → 反转 → 101 = 5
%       6 = 110 → 反转 → 011 = 3
%       7 = 111 → 反转 → 111 = 7
%
%   结果: [0, 4, 2, 6, 1, 5, 3, 7] + 1 = [1, 5, 3, 7, 2, 6, 4, 8] (MATLAB索引)
%
% 【实现方法】
%   逐位处理:
%   1. 提取原值的最低位 (bitand(values, 1))
%   2. 将结果左移一位，加上提取的位 (reversed = reversed*2 + bit)
%   3. 将原值右移一位 (values = values / 2)
%   4. 重复 log2(N) 次
%
% 【输入参数】
%   N - 序列长度 (必须是 2 的整数次幂)
%
% 【输出参数】
%   idx - 比特反转后的索引数组 (N×1)，索引从 1 开始

    % 计算需要处理的位数 = log2(N)
    num_bits = log2(N);
    
    % 原始值: 0, 1, 2, ..., N-1 (列向量)
    values = (0:N-1).';
    
    % 初始化反转结果为全零
    reversed = zeros(N, 1);

    % 逐位反转循环
    for bit = 1:num_bits
        % reversed = reversed * 2 + (values 的最低位)
        % bitshift(reversed, 1): 左移一位 (相当于乘2)
        % bitand(values, 1): 提取最低位 (0 或 1)
        reversed = bitshift(reversed, 1) + bitand(values, 1);
        
        % values = values / 2 (舍弃最低位)
        % bitshift(values, -1): 右移一位
        values = bitshift(values, -1);
    end

    % MATLAB 索引从 1 开始，需要 +1
    idx = reversed + 1;
end
