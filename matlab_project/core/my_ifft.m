function x = my_ifft(X)
% =========================================================================
%                   基于 FFT 的快速逆傅里叶变换 (IFFT) 实现
% =========================================================================
%
% 【算法概述】
%   本函数实现了逆快速傅里叶变换 (Inverse Fast Fourier Transform, IFFT)，
%   采用一种巧妙的方法：利用 FFT 函数来高效计算 IFFT。
%
%   IFFT 是离散傅里叶变换 (DFT) 的逆运算:
%   - FFT 将时域信号转换为频域表示
%   - IFFT 将频域表示还原为时域信号
%   - 两者互为逆运算: IFFT(FFT(x)) = x
%
% 【IDFT 定义】
%   对于长度为 N 的频域序列 X[k]，其逆离散傅里叶变换 (IDFT) 定义为:
%
%       x[n] = (1/N) · Σ(k=0 to N-1) X[k] · W_N^(-nk)
%
%   其中 W_N^(-1) = e^(+j·2π/N) 为逆旋转因子
%
%   对比 DFT 定义:
%       X[k] = Σ(n=0 to N-1) x[n] · W_N^(nk),  W_N = e^(-j·2π/N)
%
% 【核心数学推导：利用 FFT 计算 IFFT】
%
%   关键观察: IDFT 与 DFT 的唯一区别在于:
%     1. 指数符号相反 (W_N^(-nk) vs W_N^(nk))
%     2. 需要除以 N 进行归一化
%
%   推导过程:
%   ─────────────────────────────────────────────────────────────────────
%   步骤 1: 从 IDFT 定义出发
%
%       x[n] = (1/N) · Σ(k=0 to N-1) X[k] · e^(+j·2π·nk/N)
%
%   步骤 2: 取 X[k] 的共轭，观察 DFT 形式
%
%       DFT(conj(X))[n] = Σ(k=0 to N-1) conj(X[k]) · e^(-j·2π·nk/N)
%
%   步骤 3: 利用复数共轭性质
%           conj(a · b) = conj(a) · conj(b)
%           conj(e^(-jθ)) = e^(+jθ)
%
%       conj(DFT(conj(X))[n]) = conj(Σ conj(X[k]) · e^(-j·2π·nk/N))
%                             = Σ X[k] · e^(+j·2π·nk/N)
%                             = N · x[n]
%
%   步骤 4: 整理得到最终公式
%
%       x[n] = (1/N) · conj(DFT(conj(X)))
%   ─────────────────────────────────────────────────────────────────────
%
%   因此: IDFT(X) = (1/N) · conj(FFT(conj(X)))
%
% 【算法流程图】
%
%   输入 X[k]          频域序列 (复数)
%       │
%       ▼
%   ┌─────────────┐
%   │  共轭运算    │    X* = conj(X)
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │   FFT 运算   │    Y = FFT(X*)
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │  共轭运算    │    Y* = conj(Y)
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │   除以 N     │    x = Y* / N
%   └─────────────┘
%       │
%       ▼
%   输出 x[n]          时域序列 (复数)
%
% 【算法优势】
%   1. 代码复用: 直接调用已有的高效 FFT 实现，无需重新实现逆变换
%   2. 计算效率: 保持 O(N·log₂N) 的时间复杂度
%   3. 数值精度: 共轭运算不引入数值误差
%   4. 维护简单: 对 FFT 的任何优化自动适用于 IFFT
%
% 【与直接 IFFT 实现的比较】
%
%   方法 A: 直接实现 IFFT (修改旋转因子符号)
%     - 需要实现完整的 IFFT 蝶形运算
%     - 旋转因子为 W_N^(-k) = e^(+j·2π·k/N)
%     - 代码量与 FFT 相当
%
%   方法 B: 本函数采用的方法 (利用 FFT)
%     - 仅需 3 步简单操作
%     - 复用已有的 FFT 函数
%     - 更易于维护和验证
%
% 【输入参数】
%   X - 频域信号，复数列向量
%       - 长度 N 必须是 2 的整数次幂 (如 2, 4, 8, 16, 32, ...)
%       - 如果输入为行向量，将自动转换为列向量
%       - X(k) 对应频率分量 f_k = (k-1) × Fs / N
%
% 【输出参数】
%   x - 时域信号，复数列向量
%       - 若原始信号为实数，恢复的信号虚部应接近于零 (数值误差范围内)
%       - x(n) 对应时间点 t_n = (n-1) / Fs
%
% 【使用示例】
%   % 验证 IFFT 是 FFT 的逆运算
%   Fs = 1000;                          % 采样频率 1000 Hz
%   t = 0:1/Fs:0.2-1/Fs;                % 采样时间向量
%   x_orig = sin(2*pi*50*t) + sin(2*pi*120*t);  % 原始信号
%
%   N = 256;                            % FFT/IFFT 点数
%   x = x_orig(1:N).';                  % 取前 N 点，转为列向量
%
%   % 正向 FFT
%   X = my_fft(x);                      % 时域 → 频域
%
%   % 逆向 IFFT
%   x_recovered = my_ifft(X);           % 频域 → 时域
%
%   % 验证重建精度
%   reconstruction_error = max(abs(x - x_recovered));
%   fprintf('重建误差: %.2e\n', reconstruction_error);  % 应接近机器精度
%
% 【Parseval 定理验证】
%   % FFT/IFFT 应满足能量守恒 (Parseval's Theorem)
%   % 时域能量 = (1/N) × 频域能量
%   energy_time = sum(abs(x).^2);
%   energy_freq = sum(abs(X).^2) / N;
%   fprintf('时域能量: %.4f, 频域能量/N: %.4f\n', energy_time, energy_freq);
%
% 【注意事项】
%   1. 输入 X 必须是有效的 DFT 结果，否则输出无物理意义
%   2. 对于实信号的 DFT，频谱具有共轭对称性: X[k] = conj(X[N-k])
%   3. 若仅对 DFT 结果进行频域处理，需确保保持此对称性
%
% 【参考文献】
%   [1] Cooley, J.W., Tukey, J.W. (1965). "An algorithm for the machine
%       calculation of complex Fourier series"
%   [2] Oppenheim, A.V., Schafer, R.W. "Discrete-Time Signal Processing"
%   [3] 程佩青. 数字信号处理教程 (第五版). 清华大学出版社
%
% =========================================================================

% =====================================================================
% 步骤 0: 输入预处理
% =====================================================================

% 确保输入为列向量
% MATLAB 中向量运算通常以列向量为主，统一格式便于后续处理
if size(X, 2) > 1
    X = X(:);  % 将行向量或矩阵转换为列向量
end

N = length(X);  % 获取频域信号长度

% 验证 N 是 2 的整数次幂
% IFFT (通过 FFT 实现) 要求输入长度为 2^m (m 为正整数)
% log2(N) 若为整数，则 mod(log2(N), 1) == 0
if N == 0 || mod(log2(N), 1) ~= 0
    error('输入长度必须是2的整数次幂 (如 2, 4, 8, 16, 32, ...)');
end

% =====================================================================
% 步骤 1: 计算输入频域信号的共轭
% =====================================================================
% 数学原理:
%   conj(X[k]) 将频域信号的相位反转
%   这是利用 FFT 计算 IFFT 的关键步骤之一
%
% 对于复数 z = a + jb:
%   conj(z) = a - jb
X_conj = conj(X);

% =====================================================================
% 步骤 2: 调用 FFT 函数
% =====================================================================
% 将共轭后的频域信号送入 FFT 进行变换
% 这一步利用了 FFT 和 IFFT 的数学对称性
%
% 数学等价:
%   FFT(conj(X)) = Σ(k=0 to N-1) conj(X[k]) · e^(-j·2π·nk/N)
fft_result = my_fft(X_conj);

% =====================================================================
% 步骤 3: 取共轭并除以 N (归一化)
% =====================================================================
% 取共轭: 将 FFT 结果的相位再次反转，恢复正确的相位
% 除以 N: IDFT 定义中的归一化因子，确保 IFFT(FFT(x)) = x
%
% 数学推导:
%   conj(FFT(conj(X))) = Σ(k=0 to N-1) X[k] · e^(+j·2π·nk/N)
%                      = N · x[n]  (根据 IDFT 定义)
%
% 因此:
%   x[n] = (1/N) · conj(FFT(conj(X)))
x = conj(fft_result) / N;

% 返回计算结果
% x 为频域信号 X 的 N 点 IDFT (即恢复的时域信号)
end
