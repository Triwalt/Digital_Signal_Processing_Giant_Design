function x = my_ifft_mix(X)
% =========================================================================
%            混合基逆快速傅里叶变换 (Mixed-Radix IFFT) 实现
% =========================================================================
%
% 【算法概述】
%   本函数实现了任意长度 N 的混合基 IFFT，是 my_fft_mix 的逆运算。
%   通过巧妙利用 FFT 与 IFFT 的共轭关系，复用 my_fft_mix 的全部算法。
%
%   核心公式: IFFT(X) = conj(FFT(conj(X))) / N
%
%   因此，本实现自动继承 my_fft_mix 的所有特性:
%   - 支持任意正整数长度 N
%   - 合数长度: 混合基 Cooley-Tukey 分解
%   - 质数长度: Bluestein 算法
%   - 小长度: 直接计算
%
% 【数学推导】
%   ─────────────────────────────────────────────────────────────────────
%   IDFT 定义:
%       x[n] = (1/N) · Σ(k=0 to N-1) X[k] · e^(+j·2π·nk/N)
%
%   DFT 定义:
%       X[k] = Σ(n=0 to N-1) x[n] · e^(-j·2π·nk/N)
%
%   观察:
%       DFT(conj(X))[n] = Σ conj(X[k]) · e^(-j·2π·nk/N)
%
%   取共轭:
%       conj(DFT(conj(X))[n]) = Σ X[k] · e^(+j·2π·nk/N) = N · x[n]
%
%   因此:
%       x[n] = (1/N) · conj(FFT(conj(X)))
%   ─────────────────────────────────────────────────────────────────────
%
% 【算法流程图】
%
%   输入 X[k]          频域序列
%       │
%       ▼
%   ┌─────────────┐
%   │  共轭运算    │    X* = conj(X)
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │  FFT 运算   │    Y = my_fft_mix(X*)
%   │  (混合基)   │    自动选择最优算法
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │  共轭运算   │    Y* = conj(Y)
%   └─────────────┘
%       │
%       ▼
%   ┌─────────────┐
%   │   除以 N    │    x = Y* / N
%   └─────────────┘
%       │
%       ▼
%   输出 x[n]          时域序列
%
% 【与 my_fft_mix 的算法组合】
%   本函数调用 my_fft_mix，因此使用相同的 Planner 策略:
%   - 合数 N: 混合基 Cooley-Tukey (mixed-radix)
%   - 小质数 (N ≤ 11): codelet (直接 DFT)
%   - 大质数 (N > 11): Bluestein 算法
%
% 【复杂度分析】
%   与 my_fft_mix 相同:
%   - O(N log N) 对于大多数情况
%   - O(N²) 仅对于非常小的 N (≤ 16)
%
% 【输入参数】
%   X - 频域信号，复数或实数向量
%       - 长度 N 可以是任意正整数
%       - 支持行向量或列向量，输出保持相同方向
%
% 【输出参数】
%   x - 时域信号，复数向量
%       - 若原始信号为实数，虚部应接近零
%       - 方向与输入相同
%
% 【使用示例】
%
%   % 示例 1: 验证 IFFT 是 FFT 的逆运算
%   n = 0:14;  % N = 15 (非 2 的幂)
%   x_orig = cos(2*pi*3*n/15) + 0.5*sin(2*pi*5*n/15);
%
%   X = my_fft_mix(x_orig);         % FFT
%   x_recovered = my_ifft_mix(X);   % IFFT
%
%   max_err = max(abs(x_orig - x_recovered));
%   fprintf('重建误差: %g\n', max_err);
%
%   % 示例 2: 与 MATLAB 内置 ifft 比较
%   N = 17;  % 质数长度
%   X = randn(1, N) + 1j*randn(1, N);
%   x1 = my_ifft_mix(X);
%   x2 = ifft(X);
%   fprintf('与 ifft() 的误差: %g\n', max(abs(x1 - x2)));
%
%   % 示例 3: 列向量测试
%   X_col = randn(12, 1) + 1j*randn(12, 1);
%   x_col = my_ifft_mix(X_col);
%   fprintf('输入是列向量: %d, 输出是列向量: %d\n', ...
%           iscolumn(X_col), iscolumn(x_col));
%
% 【注意事项】
%   1. 对于实信号的 FFT 结果，具有共轭对称性: X[k] = conj(X[N-k])
%   2. 若对频域进行处理，需保持此对称性以得到实时域信号
%   3. 数值精度约为 1e-14 ~ 1e-15 (双精度浮点)
%
% 【参考文献】
%   [1] Oppenheim, A.V., Schafer, R.W. "Discrete-Time Signal Processing"
%   [2] 程佩青. 数字信号处理教程 (第五版). 清华大学出版社
%
% =========================================================================

% =====================================================================
% 步骤 0: 输入验证
% =====================================================================

% 确保输入是向量
if ~isvector(X)
    error('my_ifft_mix:InputNotVector', '输入X必须是一维向量');
end

% =====================================================================
% 步骤 1: 记录输入方向
% =====================================================================
% 保存原始方向，以便输出保持一致
wasColumn = iscolumn(X);

% =====================================================================
% 步骤 2: 统一为行向量处理
% =====================================================================
X = X(:).';

% =====================================================================
% 步骤 3: 利用共轭关系计算 IFFT
% =====================================================================
% 公式: ifft(X) = conj(fft(conj(X))) / N
%
% 这个公式的优点:
% 1. 复用 my_fft_mix 的全部算法和优化
% 2. 无需单独实现 IFFT 的旋转因子
% 3. 代码维护简单，FFT 的任何改进自动适用于 IFFT

N = length(X);

% 步骤 3.1: 取输入的共轭
X_conj = conj(X);

% 步骤 3.2: 调用 my_fft_mix (复用所有 Planner 策略)
x_tmp = my_fft_mix(X_conj);

% 步骤 3.3: 取共轭并除以 N (归一化)
x_row = conj(x_tmp) / N;

% =====================================================================
% 步骤 4: 恢复原始方向
% =====================================================================
if wasColumn
    x = x_row.';
else
    x = x_row;
end
end
