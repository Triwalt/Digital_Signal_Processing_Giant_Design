function X = my_fft_mix(x)
% =========================================================================
%            混合基快速傅里叶变换 (Mixed-Radix FFT) 实现
% =========================================================================
%
% 【算法概述】
%   本函数实现任意长度 N 的 FFT，不要求 N 为 2 的整数次幂。
%   设计思路类似 FFTW 的 "Planner"：先判断 N 的结构，再选择合适的算法路径。
%
%   - N 为合数: 优先使用混合基 Cooley-Tukey 分解，将 N 拆成 r×m 的小 FFT 组合
%   - N 为质数且较大: 使用 Bluestein (Chirp-Z) 将 DFT 转成卷积，再用 FFT 加速
%   - N 很小: 直接 DFT (O(N^2))，避免递归/卷积的常数开销
%
%   与本仓库的 `my_fft.m` (基2 DIT) 相比：
%   - `my_fft.m` 追求 "原位(in-place) + 规则蝶形"，适合 2^m 点与硬件映射
%   - `my_fft_mix.m` 追求 "任意点数可用"，以递归与数据重排换取通用性
%
% 【Planner 策略】
%   ┌────────────────────────────────────────────────────────────────┐
%   │  输入长度 N                                                     │
%   │      │                                                         │
%   │      ├── N 是质数 ───┬── N ≤ 11 ──→ Codelet (直接DFT)           │
%   │      │               └── N > 11 ──→ Bluestein O(N logN)        │
%   │      │                                                         │
%   │      └── N 是合数 ───┬── N ≤ 16 ──→ 直接 DFT O(N²)              │
%   │                      └── N > 16 ──→ 混合基分解 (递归)           │
%   └────────────────────────────────────────────────────────────────┘
%
% 【混合基 Cooley-Tukey 算法】
%   对于合数 N = r × m (本实现取 r 为最小因子，使递归更快收敛)，将 N 点 DFT 分解为:
%   1) "列变换"：把输入 reshape 成 m×r，对每一列做 m 点 FFT
%   2) "旋转因子"：对中间结果乘 twiddle[k,j] = exp(-j·2π·k·j/N)
%   3) "行变换"：对每一行做 r 点 FFT，并按输出索引规则写回一维序列
%
%   可视化示例 (N=80=5×16，本实现取最小因子 r=5, m=16；输入用 x0..x79 表示):
%   ---------------------------------------------------------------------
%   设输入为行向量:
%       x = [x0 x1 x2 ... x79]
%
%   (1) 重排: x_mat = reshape(x, m, r) 得到 16×5 矩阵 (MATLAB 按列填充):
%       第 1 列: [x0  x1  ... x15]'
%       第 2 列: [x16 x17 ... x31]'
%       第 3 列: [x32 x33 ... x47]'
%       第 4 列: [x48 x49 ... x63]'
%       第 5 列: [x64 x65 ... x79]'
%     等价索引关系:
%       x_mat(n0+1, n1+1) = x( m*n1 + n0 + 1 )
%       其中 n0=0..15, n1=0..4。
%
%   (2) 列 FFT: 对每列做 16 点 FFT，得到 X_col(16×5)
%
%   (3) 旋转因子: 对 X_col(k+1, j+1) 乘 twiddle(k,j)
%       twiddle(k,j) = exp(-j*2*pi*(k*j)/80)
%       - k = 0..15 (行索引)
%       - j = 0..4  (列索引)
%       乘法按元素进行，twiddle 的尺寸同为 16×5。
%
%   (4) 行 FFT: 对每一行做 5 点 FFT，得到 row_fft(1×5)
%
%   (5) 回写输出: 使用 idx = k1 + m*k2 + 1 (m=16)
%       - k1=0..15 对应 "行号"
%       - k2=0..4  对应 "行 FFT 输出索引"
%       输出 X 的下标为:
%         k1 固定时写入: X(k1+1), X(k1+17), X(k1+33), X(k1+49), X(k1+65)
%       即每隔 16 个点写一个，共写 5 个点。
%
%   可视化示例 (N=15=3×5，取 r=3, m=5；输入用符号 a..o 表示):
%       x = [a b c d e  f g h i j  k l m n o]
%       reshape(x, m, r) 得到 5×3 矩阵 (MATLAB 按列填充):
%           [ a  f  k
%             b  g  l
%             c  h  m
%             d  i  n
%             e  j  o ]
%       - 第 1 列 [a b c d e] 做 5 点 FFT
%       - 第 2 列 [f g h i j] 做 5 点 FFT
%       - 第 3 列 [k l m n o] 做 5 点 FFT
%       之后对第 k 行(0..m-1)做 3 点 FFT，并用 idx = k + m*k2 + 1 映射回输出
%
%   数学原理:
%       X[k₀ + m·k₁] = Σ(n₁) { W_N^(k₀·n₁) ·
%                      [ Σ(n₀) x[m·n₁+n₀] · W_m^(n₀·k₀) ] } · W_r^(n₁·k₁)
%
% 【Bluestein 算法 (处理质数长度)】
%   对于较大的质数 N，Cooley-Tukey 无法因式分解。
%   Bluestein 将 N 点 DFT 转换为长度 M(取 2 的幂) 的卷积问题:
%
%       X[k] = exp(-jπk^2/N) · (a ⊛ b)[k]
%       a[n] = x[n] · exp(-jπn^2/N)
%       b[n] = exp(+jπn^2/N)
%
%   其中 (a ⊛ b) 可通过 FFT 卷积实现:
%       (a ⊛ b) = IFFT( FFT(a_pad) .* FFT(b_pad) )
%
%   备注:
%   - Bluestein 会引入零填充与额外 FFT/ IFFT，常数因子较大
%   - 因此本实现仅在 "大质数" 场景使用 Bluestein，小质数直接 DFT 更划算
%
% 【复杂度分析】
%   N = 2^m       : O(N log N)
%   N = r₁·r₂·... : O(N log N)
%   N 为大质数    : O(N log N) (常数因子较大)
%   N ≤ 16        : O(N²)
%
% 【输入参数】
%   x - 输入信号，复数或实数向量，长度 N 可为任意正整数
%       支持行向量或列向量，输出保持相同方向
%
% 【输出参数】
%   X - x 的 N 点 DFT 结果，方向与输入相同
%
% 【使用示例】
%   n = 0:14;  % N = 15 = 3 × 5
%   x = cos(2*pi*3*n/15) + 0.5*sin(2*pi*5*n/15);
%   X1 = my_fft_mix(x);
%   X2 = fft(x);
%   max_err = max(abs(X1 - X2));
%   fprintf('与 fft() 的最大差异: %g\n', max_err);
%
% 【参考文献】
%   [1] Cooley, J.W., Tukey, J.W. (1965). "An algorithm for the machine
%       calculation of complex Fourier series"
%   [2] Bluestein, L.I. (1970). "A linear filtering approach to the
%       computation of discrete Fourier transform"
%   [3] Frigo, M., Johnson, S.G. (2005). "The Design and Implementation
%       of FFTW3"
%
% =========================================================================

% 确保输入是向量
if ~isvector(x)
    error('my_fft_mix:InputNotVector', '输入x必须是一维向量');
end

% 记住原始方向（行向量或列向量）
wasColumn = iscolumn(x);

% 内部统一使用行向量处理
x = x(:).';

% 调用递归混合基FFT核心函数
X = local_fft_mix(x);

% 恢复原始向量方向
if wasColumn
    X = X.';
end
end

% =========================================================================
% 递归混合基 FFT 核心函数
% =========================================================================
function X = local_fft_mix(x)
% local_fft_mix: 混合基 FFT 的递归实现
%   根据输入长度 N 自动选择算法:
%   - 小质数 (≤11): codelet
%   - 大质数 (>11): Bluestein
%   - 合数 (≤16): 直接 DFT
%   - 合数 (>16): 混合基 Cooley-Tukey

% =====================================================================
% 步骤 0: 获取序列长度
% =====================================================================
% 与 `my_fft.m` 的 "要求 N=2^m" 不同，本函数允许任意 N

N = length(x);

% -----------------------------------------------------------------
% 情况 1: 质数长度
% -----------------------------------------------------------------
% 质数 N 无法做 Cooley-Tukey 因式分解。
% 这里做一个 "常数项" 层面的权衡：
%   - N 很小: 直接 DFT 反而更快
%   - N 较大: Bluestein 通过卷积 + FFT 把复杂度降到 O(N log N)
if isprime(N)
    if N <= 11
        % 小质数: codelet (可替换为优化实现)
        X = fft_codelet_small_prime(x);
    else
        % 大质数: Bluestein 算法
        X = bluestein_fft(x);
    end
    return;
end

% -----------------------------------------------------------------
% 情况 2: 极小合数
% -----------------------------------------------------------------
% 虽然合数可以分解，但当 N 很小时，递归/重排/旋转因子的开销可能超过收益
if N <= 16
    X = dft_direct(x);
    return;
end

% -----------------------------------------------------------------
% 情况 3: 合数 N > 16 - 混合基 Cooley-Tukey
% -----------------------------------------------------------------
r = smallest_factor(N);  % 找最小因子

if isempty(r) || r == 1 || r == N
    X = dft_direct(x);
    return;
end

m = N / r;  % N = r × m

% 步骤 1: 重排为 m×r 矩阵，对每列做 m 点 FFT
% =====================================================================
% 步骤 1: 数据重排 + 列 FFT (m 点)
% =====================================================================
% 关键点：MATLAB 的 reshape 是 "按列" 填充。
% 这意味着 x 会按如下方式映射到矩阵 x_mat:
%   x_mat(n0+1, n1+1) = x(m*n1 + n0 + 1)
%
% 可视化示例 (N=80=5×16，r=5, m=16；输入用 x0..x79 表示):
%   x = [x0 x1 ... x79]
%   x_mat = reshape(x, 16, 5) 的每一列为:
%     col1 = [x0  x1  ... x15]'
%     col2 = [x16 x17 ... x31]'
%     col3 = [x32 x33 ... x47]'
%     col4 = [x48 x49 ... x63]'
%     col5 = [x64 x65 ... x79]'
%   随后对每列做 16 点 FFT，得到 X_col(16×5)
%
% 可视化示例 (N=15=3×5，m=5, r=3；x 为行向量):
%   x = [a b c d e  f g h i j  k l m n o]
%   x_mat = reshape(x, 5, 3) =
%       [ a  f  k
%         b  g  l
%         c  h  m
%         d  i  n
%         e  j  o ]
%
% 然后对每一列做 m 点 FFT，相当于计算:
%   X_col(:, j+1) = FFT_m( x_mat(:, j+1) )
x_mat = reshape(x, m, r);
X_col = zeros(m, r);
for j = 1:r
    X_col(:, j) = local_fft_mix(x_mat(:, j).').';
end

% 步骤 2: 乘以旋转因子
% =====================================================================
% 步骤 2: 旋转因子 (Twiddle) 相乘
% =====================================================================
% 在 Cooley-Tukey 的分解中，需要对 "列 FFT" 的结果乘以 twiddle:
%   twiddle(k, j) = exp(-j*2*pi*(k*j)/N)
% 其中 k=0..m-1, j=0..r-1。
%
% 可视化示例 (N=80, r=5, m=16):
%   k      = (0:15)'  -> 16×1
%   j_idx  = 0:4      -> 1×5
%   k*j_idx            -> 16×5 (外积生成网格)
%   twiddle            -> 16×5
%   X_col              -> 16×5
%   X_col .* twiddle   -> 16×5 (按元素相乘)
%
%   举例：第 k=3 行、第 j=2 列对应的旋转因子为:
%       twiddle(3,2) = exp(-j*2*pi*(3*2)/80) = exp(-j*2*pi*6/80)
%   (注意这里的 k、j 为从 0 开始的数学索引；代码中对应行列要 +1)
%
% 代码中:
%   k      -> (0:m-1)'  (列向量)
%   j_idx  -> 0:(r-1)   (行向量)
%   k*j_idx 通过外积生成 m×r 网格
%   exp(...) 得到 m×r 的 twiddle 矩阵，与 X_col 按元素相乘
k = (0:m-1).';
j_idx = 0:(r-1);
twiddle = exp(-1j * 2 * pi * (k * j_idx) / N);
X_col = X_col .* twiddle;

% 步骤 3: 对每行做 r 点 FFT，映射到输出
% =====================================================================
% 步骤 3: 行 FFT (r 点) + 输出索引映射
% =====================================================================
% 对于每个 k1 = 0..m-1：取第 (k1+1) 行做 r 点 FFT
%   row_fft = FFT_r( X_col(k1+1, :) )
%
% 可视化示例 (N=80, r=5, m=16):
%   - 每一行长度为 5：row = [X_col(k1+1,1) ... X_col(k1+1,5)]
%   - 对该行做 5 点 FFT，得到 row_fft(1×5)
%
%   回写索引 idx = k1 + m*k2 + 1 (m=16) 的具体落点为:
%     k2=0 -> idx = k1 + 1
%     k2=1 -> idx = k1 + 17
%     k2=2 -> idx = k1 + 33
%     k2=3 -> idx = k1 + 49
%     k2=4 -> idx = k1 + 65
%   因此每个 k1 会写入 5 个位置，间隔恒为 16。
%   举例：k1=3 时写入 X(4), X(20), X(36), X(52), X(68)。
%
% 输出索引映射采用:
%   idx = k1 + m*k2 + 1   (k2 = 0..r-1)
% 即把二维频域索引 (k1,k2) 写回到一维输出 X 的位置
X = zeros(1, N);
for k1 = 0:(m-1)
    row = X_col(k1+1, :);
    row_fft = local_fft_mix(row);
    for k2 = 0:(r-1)
        idx = k1 + m * k2 + 1;
        X(idx) = row_fft(k2+1);
    end
end
end

% =========================================================================
% 直接 DFT 实现 - O(N²)
% =========================================================================
function X = dft_direct(x)
% dft_direct: 矩阵乘法实现的直接 DFT
%   X[k] = Σ x[n] · W_N^(nk), W_N = exp(-j·2π/N)

N = length(x);
n = 0:N-1;
k = n.';
W = exp(-1j * 2 * pi / N);
F = W .^ (k * n);
X = (F * x(:)).';
end

% =========================================================================
% 小质数 Codelet
% =========================================================================
function X = fft_codelet_small_prime(x)
% fft_codelet_small_prime: 小质数长度的 FFT
%   当前实现: 直接 DFT
%   可替换为: Winograd 或 C/MEX 优化实现

X = dft_direct(x);
end

% =========================================================================
% Bluestein FFT 算法
% =========================================================================
function X = bluestein_fft(x)
% bluestein_fft: Bluestein (Chirp-Z) 算法
%   将 N 点 DFT 转为卷积，用 FFT 加速
%   复杂度: O(N log N)

N = length(x);
n = 0:N-1;

% 调制序列: a[n] = x[n] · exp(-jπn²/N)
x_row = x(:).';
a = x_row .* exp(-1j * pi * (n.^2) / N);

% Chirp 序列: b[n] = exp(jπn²/N)
b = exp(1j * pi * (n.^2) / N);

% 卷积长度: 2 的幂
M = 2^nextpow2(2 * N - 1);

% 零填充
a_pad = [a, zeros(1, M - N)];
b_pad = [b, zeros(1, M - 2 * N + 1), b(N:-1:2)];

% FFT 卷积
A = my_fft_mix(a_pad);
B = my_fft_mix(b_pad);
C = A .* B;
c = my_ifft_via_fft(C);

% 后处理
c = c(1:N);
X = exp(-1j * pi * (n.^2) / N) .* c;
X = X(:).';
end

% =========================================================================
% 利用 FFT 实现 IFFT
% =========================================================================
function x = my_ifft_via_fft(X)
% my_ifft_via_fft: IFFT(X) = conj(FFT(conj(X))) / N

N = length(X);
X_row = X(:).';
x = conj(my_fft_mix(conj(X_row))) / N;
x = x(:).';
end

% =========================================================================
% 寻找最小因子
% =========================================================================
function f = smallest_factor(N)
% smallest_factor: 返回 N 的最小非平凡因子 (2 ≤ f ≤ √N)
%   若 N 是质数，返回空数组 []

if N <= 3
    f = [];
    return;
end

if mod(N, 2) == 0
    f = 2;
    return;
end

limit = floor(sqrt(N));
for d = 3:2:limit
    if mod(N, d) == 0
        f = d;
        return;
    end
end

f = [];
end
