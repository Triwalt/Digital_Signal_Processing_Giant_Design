# 1. 幂2基的任意点数并行FFT算法


猜测的重点
- 和课内 DIT 2 FFT 算法流图详细结合

要点
- 结合流图，解释原位计算过程【原位计算 reshape】
- 解释 cache，让 fft 更快
- 利用 matlab 全局缓存


手动实现旋转因子的计算与优化，周期性对称性的体现
- 计算蝶形因子本身时是利用 N/2
    - 在 `get_fft_cache` 里预计算 `twiddle_full = exp(-1j*2*pi*(0:(N/2-1))/N).'` 只存前 `N/2` 个旋转因子，利用 $W_N^{k+N/2}=-W_N^k$ 的半周期对称性避免存满 N 个（见约 lines 270–280） 
- 读取索引
    - 读取索引：每个 stage 的 `idx_vec = (0:half_span-1)*stride + 1` 只是从 `twiddle_full` 抽取需要的子序列，stride = `N/span` 保证按对称性等间隔取样，不重复存储（约 lines 295–310）
- 计算蝶形因子
    - 计算蝶形因子：蝶形时用 `twiddle_mul = W .* bot_val`，其中 `W` 已按上述对称性抽取；不再重复计算/存储下半周期的 twiddle，计算量和访问量都基于 N/2 的缓存（约 lines 175–205）
- 权衡
    - 空间换时间
    - 如果做了空间上周期对称性优化，调用方式变复杂
    - 需要多次 fft 每次 fft 要重新算复杂的调用方式，在当前场景的开销不太适合

性能对比
- 不同点数 FFT 的正确性验证
    - 准确度
    - 耗时、速度
    - 画图

# 2. 80点并行FFT算法

mix 总策略

测试结果图
- 强调 255、256、257 周围混合积
- 解释测试实例（自己的 vs matlab 的趋势一不一致）
    - 精度
    - 耗时


# 3. 重叠保留法 && 重叠相加法

做了，展示结果

快速卷积与直接卷积的结果对比
- 准确度
- 耗时、速度
- 画图

重叠相加/保留法的正确性验证
- 准确度
- 耗时、速度
- 画图

# 4. CMA 均衡前后的信号质量对比

CMA 代码补全

测试结果
- CMA 均衡前后的信号质量对比
- 与时域实现对比
    - 星座图
    - 末尾的100的点
    - 总体差错

讲解我们引入符号体系和公式实现

原理要点
- seg len 信号进来
- 
- 频域卷积
- 没有直接使用完整重叠保留
    - 需要一段 seg len 一段 seg len 进行计算，每一段 seg len 更新一次抽头，抽头更新
    - 重叠保留是 长序列一直卷积短序列 其中不会更新抽头系数
- 更新梯度 / par num
    - acc 累计量 = 0
    - 正比例函数，不是有截距的
    - 因为我们模拟硬件行为，等到 4 个 seg 多加了 4 次所以除以 4

- 加两次 tap num -1 

# 5. 基于Verilog设计并行FFT算法

位宽定义定点数


流水线
- gemini 模块化流程图

并行（上版本）
- 串级的并行
    - 并行度
    - lane
    - 没有直接计算 all 蝶形单元，节省乘法器开销
- LUT ram 使用比较多

测试结果
- testbanch
- 资源开销


